From 3a80a711cb5e95ac56f68da1df8561ce6320426b Mon Sep 17 00:00:00 2001
From: Cjacker <jianzhong.huang@i-soft.com.cn>
Date: Tue, 30 Jun 2020 15:16:40 +0800
Subject: [PATCH 1/4] Add X Input Method support to devdraw

---
 src/cmd/devdraw/x11-screen.c | 54 +++++++++++++++++++++++++++++++++++-
 1 file changed, 53 insertions(+), 1 deletion(-)

diff --git a/src/cmd/devdraw/x11-screen.c b/src/cmd/devdraw/x11-screen.c
index 0bbc25d6..77e39299 100644
--- a/src/cmd/devdraw/x11-screen.c
+++ b/src/cmd/devdraw/x11-screen.c
@@ -10,6 +10,7 @@
 #include <mouse.h>
 #include <cursor.h>
 #include <thread.h>
+#include <locale.h>
 #include "x11-memdraw.h"
 #include "devdraw.h"
 
@@ -60,6 +61,12 @@ static ClientImpl x11impl = {
 	rpc_flush
 };
 
+static XIC xic;
+static XIM xim;
+static XPoint spot;
+static XVaNestedList spotlist;
+
+
 static Xwin*
 newxwin(Client *c)
 {
@@ -161,6 +168,8 @@ gfx_main(void)
 	/*
 	 * Connect to X server.
 	 */
+        setlocale(LC_CTYPE, "");
+        XSetLocaleModifiers("");
 	_x.display = XOpenDisplay(NULL);
 	if(_x.display == nil){
 		disp = getenv("DISPLAY");
@@ -307,6 +316,8 @@ xloop(void)
 		xlock();
 		while(XPending(_x.display)) {
 			XNextEvent(_x.display, &event);
+			if (XFilterEvent(&event, None))
+				  continue;
 			runxevent(&event);
 		}
 	}
@@ -319,6 +330,9 @@ static void
 runxevent(XEvent *xev)
 {
 	int c;
+	char buf[64]; 
+	Rune rbuf[64];
+	Status status;
 	KeySym k;
 	static Mouse m;
 	XButtonEvent *be;
@@ -364,7 +378,14 @@ runxevent(XEvent *xev)
 	case KeyPress:
 		w = findxwin(((XKeyEvent*)xev)->window);
 		break;
+	case FocusIn:
+		if (xic)
+			XSetICFocus(xic);
+		w = findxwin(((XFocusChangeEvent*)xev)->window);
+		break;
 	case FocusOut:
+		if (xic)
+			XUnsetICFocus(xic);
 		w = findxwin(((XFocusChangeEvent*)xev)->window);
 		break;
 	}
@@ -407,8 +428,16 @@ runxevent(XEvent *xev)
 	case KeyRelease:
 	case KeyPress:
 		ke = (XKeyEvent*)xev;
-		XLookupString(ke, NULL, 0, &k, NULL);
+		if (xic && xev->type == KeyPress) {
+			bzero(buf, 64);
+			int len = Xutf8LookupString(xic, ke, buf, sizeof buf, &k, &status);
+			if(len > 0)
+				runesnprint(rbuf, 64, "%s", buf);
+		} else 
+			XLookupString(ke, NULL, 0, &k, NULL);
+
 		c = ke->state;
+
 		switch(k) {
 		case XK_Alt_L:
 		case XK_Meta_L:	/* Shift Alt on PCs */
@@ -458,8 +487,20 @@ runxevent(XEvent *xev)
 			_xmovewindow(w, w->fullscreen ? w->screenrect : w->windowrect);
 			return;
 		}
+
+		if(xic && xev->type == KeyPress) {
+			int nr = runestrlen(rbuf);
+			if (status == XLookupChars && nr > 0 ) {
+				int i = 0;
+				while(i < nr) {
+					gfx_keystroke(w->client, rbuf[i++]);
+				}
+			}
+		}
+
 		if((c = _xtoplan9kbd(xev)) < 0)
 			return;
+
 		gfx_keystroke(w->client, c);
 		break;
 
@@ -592,6 +633,17 @@ xattach(Client *client, char *label, char *winsize)
 		&attr		/* attributes (the above aren't?!) */
 	);
 
+        /* input methods */
+        xim = XOpenIM(_x.display, 0, 0, 0);
+        spotlist = XVaCreateNestedList(0, XNSpotLocation, &spot,
+                                              NULL);
+
+        if (xim)
+                xic = XCreateIC(xim, 
+				XNInputStyle, XIMPreeditNothing|XIMStatusNothing, 
+				XNClientWindow, w->drawable, 
+				NULL);
+
 	/*
 	 * Label and other properties required by ICCCCM.
 	 */
-- 
2.35.1

